<!DOCTYPE html>
<html lang="ru">

<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="refresh" content="0; url=https://vsky.space">
<meta vdebugmode="ios">

<script>
  (function () {
    const ua = navigator.userAgent.toLowerCase();
    const isMobile = /iphone|ipad|android/.test(ua);

    if (isMobile) {
      // Ранний мгновенный редирект — ещё до загрузки твоего большого Main
      location.replace("https://vsky.space/ios/");
    }
  })();
</script>


<title>вский.space</title>

<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:#000;color:#ccc;font-family:system-ui,Segoe UI,Roboto,Arial}
  .overlay{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    z-index:1000;
  }

  /* Контейнер: строки/строки из кнопок, но кнопки занимают только свою ширину */
  .buttonblock{
    display:flex;
    flex-wrap:wrap;           
    gap:16px;
    width: min(90vw, 700px);
    height: min(90vh, 680px);
    align-content:center;
    justify-content: space-between; 
    padding:20px;
    background:transparent;
  }

  /* Кнопки:  */
  .buttonblock button{
    flex: 0 0 auto;  
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:12px 12px;
    font-size:1.25rem;
    color: gray;
    background: rgba(0,0,0,0.0);
    border: 0;
    cursor:pointer;
    transition: opacity .6s ease, transform .45s cubic-bezier(.2,.9,.2,1);
    will-change: opacity, transform;
    z-index: 99;
  }

  /* Hover для обычных кнопок */
  .buttonblock button:not(#close):hover {
    opacity: .5;
  }
  /* Опционально: визуально отключаем hover для закрытых кнопок */
  .buttonblock button#close {
    cursor: grab;
    color: rgba(70,70,70,1.0);
  }
  .buttonblock button#close:active {
    cursor: grabbing; /* сжатая ладонь */
    transform: scale(0.99); /* чуть увеличиваем */
    color: rgba(50,50,50,1.0); /* светлеем */
  }



  /* класс скрытия: плавно пропадает и перестаёт принимать события */
  .hidden-btn{
    opacity: 0 !important;
    pointer-events: none !important;
  }

  /* после завершения анимации мы дополнительно ставим visibility:hidden (JS) —
     это защищает от :hover и от фокусировки через клавиатуру */
  .background{
    position:absolute;inset:0;background:#000;z-index:0;transition:opacity 1.2s ease;
  }

  /* маленькие устройства — уменьшаем отступ и шрифт */
  @media (max-width:420px){
    .buttonblock{gap:10px;padding:12px}
    .buttonblock button{padding:10px 14px;font-size:1rem}
  }
</style>
</head>
<body>


<div class="overlay" id="overlay">
  <div class="buttonblock" id="buttonblock"> 
    <button data-href="https://vsky.space/негативы/"id="open">негативы</button>
    <button data-href="https://vsky.space/chat"     id="open">chat___</button>
    <button data-href="https://vsky.space/день/"    id="open">день</button>
    <button data-href="https://vsky.space/триптих/" id="open">триптих</button>
    <button data-href="https://vsky.space/exegesis" id="open">.exe</button>

    <button data-href="https://vsky.space/wolume/"   id="open">~</button>
    <button data-href="https://vsky.space/identity/" id="close">identity</button>
    
    <button data-href="bread/"    id="close">bread</button>
    <button data-href="renders/"  id="close">_enders</button>
    <button data-href="halo/"     id="close">[ haloguys ]</button>
    <button data-href="pocpocci/" id="close">покпокки</button>
    <button data-href="work/"     id="close">работа</button>
    <button data-href="process/"  id="close">_cess</button>
    <button data-href="shoots/"   id="close">снимки</button>
    <button data-href="const/"    id="close">/</button>
    <button data-href="graphics/" id="close">графика</button>
    <button data-href="space/"    id="close">—</button>
    <button data-href="about/"    id="close">[ ❤ ]</button>
  </div>
  <div class="background" id="background"></div>
</div>


<script>
  const debugMode = false // document.querySelector('meta[vdebugmode]').getAttribute('vdebugmode');

  //document.querySelectorAll('button').forEach(btn => {
  document.querySelectorAll('#buttonblock button[id="open"]').forEach(btn => {
      btn.addEventListener('click', () => {
          let target = btn.dataset.href;
          if (btn.id === 'close') {
            ev.preventDefault(); // блокируем переход
            return false;        // ничего не делаем
          }
          if (window.location.protocol === "file:") {
              // локальная отладка: путь относительно index.html
              if (target.startsWith("/")) target = target.slice(1);
              target = target + ".html";
          } else {
              // серверная версия — просто рут
              if (target.endsWith(".html")) {
                  target = "/" + target.replace(".html", "");
              }
          }

        if (debugMode === "ios") {
            // вставляем "_ios" перед ".html"
            target = target.replace(/\.html$/, "_ios.html");
        }
          window.location.href = target;
      });
  });

  const buttonBlock = document.getElementById('buttonblock');
  const buttons = Array.from(buttonBlock.querySelectorAll('button'));


  // ВОССТАНОВЛЕНИЕ ПОСЛЕ ВОЗВРАТА НАЗАД
  window.addEventListener("pageshow", (event) => {
    if (event.persisted) {
      // только восстанавливаем видимость скрытых кнопок
      buttons.forEach(btn => {
        if(btn.classList.contains('hidden-btn')){
          btn.classList.remove('hidden-btn');
          btn.style.visibility = 'visible';
        }
      });
      buttonBlock.style.pointerEvents = "";
    }
  });

  /* ========== Автоматическая подстройка размера шрифта в зависимости от кол-ва кнопок ==========
     простая эвристика: чем больше кнопок — тем меньше шрифт (можно настроить под себя).
  */
  (function adjustFontByCount(){
    const n = buttons.length;
    // примерная формула: 1.6rem при 1-3 кнопках, уменьшаем при большем числе
    const base = 4.6; // rem
    const sizeRem = Math.max(0.9, base - (n - 3) * 0.12);
    buttons.forEach(b => b.style.fontSize = sizeRem + 'rem');
  })();


  function hideAllButtons() {
    return new Promise(resolve => {
      let finished = 0;
      const total = buttons.length;

      function onTransitionEnd(e) {
        if (e.propertyName !== 'opacity') return;
        finished++;
        if (finished >= total) {
          cleanup();
          buttons.forEach(btn => btn.style.visibility = 'hidden');
          resolve();
        }
      }

      function cleanup(){
        buttons.forEach(btn => btn.removeEventListener('transitionend', onTransitionEnd));
      }

      // привязываем слушатель И запускаем анимацию скрытия
      buttons.forEach(btn => btn.addEventListener('transitionend', onTransitionEnd));
      // небольшая задержка, чтобы гарантировано применился класс и началась анимация
      requestAnimationFrame(() => {
        buttons.forEach(btn => btn.classList.add('hidden-btn'));
      });

      // safety fallback — если transitionend не сработает, через 1.2s всё равно продолжим
      setTimeout(() => {
        if (finished < total) {
          cleanup();
          buttons.forEach(btn => btn.style.visibility = 'hidden');
          resolve();
        }
      }, 1400);
    });
  }

  function shuffleButtonsWithInternalRules() {
    const container = document.getElementById('buttonblock');
    const buttons = Array.from(container.querySelectorAll('button'));

    if (buttons.length <= 2) return;

    // находим фиксированные
    const last = buttons.find(b => b.dataset.href === "about/");
    const pre_a = buttons.find(b => b.dataset.href === "space/");
    const pre_b = buttons.find(b => b.dataset.href === "halo/");

    const pre_excl_a = buttons.find(b => b.dataset.href === "wolume/");
    const pre_excl_b = buttons.find(b => b.dataset.href === "const/");

    // остальные кнопки
    const rest = buttons.filter(b => b !== last && b !== pre_a && b !== pre_b);

    // Fisher–Yates shuffle
    for (let i = rest.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [rest[i], rest[j]] = [rest[j], rest[i]];
    }

    // очищаем контейнер и вставляем кнопки
    container.innerHTML = "";

    // вставляем все перемешанные кнопки
    rest.forEach(btn => container.appendChild(btn));

    // вставляем две фиксированные кнопки конца
    container.appendChild(pre_b); 
    container.appendChild(pre_a);
    container.appendChild(last); 
  }


  function shuffleButtonsWithInternalRulesB() {
    const container = document.getElementById('buttonblock');
    const buttons = Array.from(container.querySelectorAll('button'));

    if (buttons.length <= 3) return; // слишком мало кнопок для перемешивания

    // находим фиксированные
    const last = buttons.find(b => b.dataset.href === "about/");
    const pre_a = buttons.find(b => b.dataset.href === "space/");
    //const pre_b = buttons.find(b => b.dataset.href === "halo/");

    // кнопки, которые нельзя ставить последними перед фиксированными
    const excl = buttons.filter(b => b.dataset.href === "wolume/" || b.dataset.href === "const/");

    // остальные кнопки
    const rest = buttons.filter(b => ![last, pre_a].includes(b));

    // функция перемешивания Fisher–Yates
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // перемешиваем, пока последний элемент локального массива не будет в excl
    let valid = false;
    while (!valid) {
      shuffle(rest);
      const lastRest = rest[rest.length - 1];
      valid = !excl.includes(lastRest);
    }

    // очищаем контейнер
    container.innerHTML = "";

    // вставляем перемешанные кнопки
    rest.forEach(btn => container.appendChild(btn));

    // вставляем фиксированные в конец
    //container.appendChild(pre_b); 
    container.appendChild(pre_a);
    container.appendChild(last); 
  }

  // вызов при загрузке
  shuffleButtonsWithInternalRulesB();


  // Вызов при загрузке
  //shuffleButtonsWithInternalRules();






</script>
</body>
</html>
